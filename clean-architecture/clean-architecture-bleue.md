# 클린 아키텍처

![클린아키텍처 이미지](../resources/CleanArchitecture-bleue.jpeg)

## 엔티티 😀

기업 규모의 비지니스 규칙
기업 규모가 아닌 하나의 어플리케이션이라면 엔티티는 어플리케이션의 비지니스 객체임
데이터 구조, 객체(함수/메소드)가 엔티티가 될 수 있음
제일 높은 레벨의 규칙으로 캡슐화 됨.
외부의 변화에 제일 변하지 않는다.

## 유즈 케이스

애플리케이션별 비지니스 규칙이 포함됨
시스템의 모든 사용 사례를 캡슐화 하고 구현
기업 전체의 비지니스 규칙을 사용하여 유즈 케이스의 목표 달성

## 인터페이스 어댑터

데이터를 유즈케이스 및 엔티티에 가장 편리한 형식에서 데이터베이스, 웹과 같은 외부와 편리한 형식으로 변환하는 어댑터

## 프레임워크 드라이버

가장 바깥쪽 계층
웹 프레임워크, 데이터베이스 등 도구
세부정보/세부사항

## Dependency Rule

소스코드의 종속성은 내부만 가리킬 수 있음
안쪽으로 갈 수 록 추상화의 수준이 높아짐
가장 밖의 원은 낮은 수준의 콘크리트 세부 사항
내부로 이동할 수록 더 추상적으로 변하고, 높은 수준의 정책을 캡슐화

## 외부 통신

컨트롤러/프레젠터가 다음 계층의 유즈케이스와 통신
컨트롤 흐름 기록 -> 컨트롤에서 시작 -> 사용사례 -> 프레젠터 실행

유즈케이스가 프레젠터를 호출할때 종속성 규칙을 위반할 수 있으므로 해당 호출은 직접적이면 안됨 => 외부의 원의 이름은 내부 원에서 언급 X => 유즈케이스를 이용하여 내부 원에 있는 인터페이스를 호출하고 외부 원에 있는 프레젠터가 해당 내용을 구현

## 추상화

복잡한, 자료, 모듈, 시스템등으로부터 핵심적인 개념 또는 기능을 간추리는 것
복잡한걸 단순하게 만들어서 더욱 복잡한 내용을 구현할 수 있음

## SOLID
### SRP
  단일 책임 원칙
  한 클래스는 하나의 책임만 가져야함
### OCP
  개방 폐쇄 원칙
  소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 함
### LSP
  리스코프 치환 원칙
  프로그램의 객체는 프로그램의 정확서을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야함
### ISP
  인터페이스 분리 원칙
  특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫음
### DIP
  의존관계 역전 원칙
  프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안됨
  의존성 주입 

## 컴포넌트 원칙 
### REP
  재사용 릴리즈 등가 원칙 
  재사용 단위는 릴리즈 단위와 같음
### CCP 
  공통 폐쇄 원칙
  동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶임
  서로 다른 시점에서 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리 
### CRP 
  공통재사용 원칙
  컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하면 안됨
![image](https://github.com/e-zip/archieve/assets/46446434/b7c0cbcd-8b02-4bcc-baab-6005855dcb2e)


## 컴포넌트 결합
### ADP
  의존선 비순환 원칙 
  컴포넌트 의존성 그래프에 순환이 있으면 안됨
### 하향식 설계 
  작은 부분에서 큰그림으로 이동하는 방식 
### SDP
  안정된 의존성 원칙
  안정성의 방향으로 의존해야함 
### SAP
  안정된 추상화 원칙 
  컴포넌트는 안정된 정도만큼만 추상화되어야함 

## 헥사고날 

![image](https://github.com/e-zip/archieve/assets/46446434/077e7ceb-ab11-4030-a189-63e4fdcb22a3)
도메인의 비지니스 로직을 외부 라이브러리 및 툴로부터 분리 할 때 포트와 어댑터로 부르는 인터페이스를 사용하기 때문에 포트&어댑터 아키텍처라고 부름 
도메인 비지니스 로직이 외부요소에 의존 X, 프레젠테이션 계층과 데이터 소스 계층같으 ㄴ외부 요소들이 도메인 계층에 의존 
아키텍처 확장에 용이
SOLID 원칙을 쉽게 적용
모듈 일부를 배포하는게 용이 

- 내부 영역
  순수한 비지니스 로직을 표현하며 캡슈로하된 영역, 기능적 요구에 따라 먼저 설계
- 외부 영역
  내부 영역에서 기술을 분리하여 구성한 영역이고, 내부 영역 설계 이후 설계 

